<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1496825948969">{:repl-history {:ide [], :local [&quot;(run-init-sequence)&quot; &quot;(run-shut-sequence)&quot; &quot;(test-def-expr)&quot; &quot;computation-tree&quot; &quot;(read-expressions)&quot; &quot;(defn rsrc-&gt;compiled-expressions\n  []\n  (for [{:keys [name definition]} (read-expressions)]\n    (def-expr name tree)))&quot; &quot;(rsrc-&gt;compiled-expressions)&quot; &quot;(RectanglePerimeter. 1 2)&quot; &quot;(ns-map *ns*)&quot; &quot;(walk/macroexpand-all\n  '(compile-resource-expressions))&quot; &quot;(-&gt; (slurp expression-rsrc) read-string rsrc-&gt;compiled-expressions)&quot; &quot;(algorithms-clj.macro-initiation/def-expr\n  RectanglePerimeter2\n  [+ [* 2 :width] [* 2 :height]])\n&quot; &quot;(macroexpand-1\n  '(compile-resource-expressions))&quot; &quot;(do\n  (algorithms-clj.macro-initiation/def-expr RectanglePerimeter [+ [* 2 :width] [* 2 :height]])\n  (algorithms-clj.macro-initiation/def-expr GravitationalPull [/ [* :m1 :m2] [* :distance :distance]]))&quot; &quot;(macroexpand-1\n   '(def-expr Yoh\n  [/ [* :m1 :m2] [* :distance :distance]]))&quot; &quot;(compile-eval-expr\n  [/ [* :m1 :m2] [* :distance :distance]])&quot; &quot;(compile-eval-expr\n  [/ [* :m1 :m2] [* :distance :distance]]\n  {})&quot; &quot;(compile-eval-expr\n  '[/ [* :m1 :m2] [* :distance :distance]]\n  {})&quot; &quot;(def-expr Yoh\n  [/ [* :m1 :m2] [* :distance :distance]])&quot; &quot;(def-expr Yoh\n  [+ [* :m1 :m2] [* :distance :distance]])&quot; &quot;(/ 1 2)&quot; &quot;(/ 1 2 3)&quot; &quot;(Yoh. 1 2 3)&quot; &quot;(eval-expr *1)&quot; &quot;(/ (* (:m1 {}) (:m2 {})) (* (:distance {}) (:distance {})))\n&quot; &quot;(/ (* (:m1 {:m1 1}) (:m2 {:m2 2}))\n  (* (:distance {:distance 1}) (:distance {:distance 1})))\n&quot; &quot;(compile-resource-expressions)&quot; &quot;(macroexpand-1\n  '(def-expr Expr2 [/ [* 2 3 :a] [* 2 :b :c]]))&quot; &quot;(resolve-operators [/ [* 2 3 :a] [* 2 :b :c]])&quot; &quot;(/)&quot; &quot;(apply / [1])&quot; &quot;(apply / [1 2 3])&quot; &quot;(apply / [])&quot; &quot;(optimize-expr (resolve-operators [/ [* 2 3 :a] [* 2 :b :c]]))&quot; &quot;(optimize-expr\n  [/ 1 2])&quot; &quot;(optimize-expr\n  [/ 1 2 :a])&quot; &quot;(optimize-expr\n  [/ :a])&quot; &quot;(optimize-expr / :a)&quot; &quot;(optimize-expr [/ :a])&quot; &quot;(optimize-expr [+ :a])&quot; &quot;(optimize-op [+ :a])&quot; &quot;+&quot; &quot;(optimize-op ['+ :a])&quot; &quot;(optimize-op [#'+ :a])&quot; &quot;(optimize-op [#'/ :a])&quot; &quot;(optimize-op\n  [#'/ 1 2])&quot; &quot;(defn optimize-op\n  [[op &amp; args :as expr]]\n  (let [variables (filter (complement number?) args)\n        constants (filter number? args)]\n    ; TODO - This breaks with /. WHY?\n    (println constants)\n    (if-not (&lt; 1 (count constants))\n      (into [op (apply op constants)] variables)\n      expr)))&quot; &quot;(optimize-op\n  [#'/ 1 2 3])&quot; &quot;(optimize-expr\n  [/ [* 2 3 :a] [* 2 :b :c]])&quot; &quot;(read-transitions (split-words (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;)) 1)&quot; &quot;(read-transitions\n  (split-words\n    (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n  1)&quot; &quot;(transition-&gt;markov-chain\n  (read-transitions\n  (split-words\n    (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n  1))&quot; &quot;(:initial-gen\n  (transition-&gt;markov-chain\n  (read-transitions\n  (split-words\n    (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n  1)))&quot; &quot;((:initial-gen\n  (transition-&gt;markov-chain\n  (read-transitions\n  (split-words\n    (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n  1))))&quot; &quot;(get\n  (:words-&gt;gen\n    (transition-&gt;markov-chain\n      (read-transitions\n        (split-words\n          (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n        1)))\n  (list \&quot;Zinédine\&quot;))&quot; &quot;((get\n  (:words-&gt;gen\n    (transition-&gt;markov-chain\n      (read-transitions\n        (split-words\n          (slurp \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;))\n        1)))\n  (list \&quot;Zinédine\&quot;)))&quot; &quot;(read-transitions\n  \&quot;This is a simple sentence\&quot; 1)&quot; &quot;(read-transitions\n  (split-words\n    \&quot;This is a simple sentence\&quot;) 1)&quot; &quot;(read-transitions\n  (split-words\n    \&quot;a b c b d\&quot;) 1)&quot; &quot;(read-transitions token-seq 1)&quot; &quot;(read-transitions (split-words \&quot;a b c b d\&quot;) 1)\n&quot; &quot;transdu&quot; &quot;(read-transitions (split-words \&quot;a b c b d\&quot;) 2)&quot; &quot;(file-&gt;markov-transitions\n  \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot;)&quot; &quot;(file-&gt;markov-transitions\n  \&quot;./src/cljc/algorithms_clj/markov-chain-input.edn\&quot; 1)&quot; &quot;(clojure.repl/doc with-open)&quot; &quot;(rand 2.0)&quot; &quot;(sorted-set 1 2 3 4)&quot; &quot;(some #(&lt; % 2) [1 2 3 4])&quot; &quot;(some #(if (&lt; % 2) %) [1 2 3 4])&quot; &quot;(sorted-set-by second\n  [[:a 1] [:b 1] [:c 0]])&quot; &quot;(apply sorted-set-by second\n  [[:a 1] [:b 1] [:c 0]])&quot; &quot;(sorted-set-by second\n  [:a 1] [:b 1] [:c 0])&quot; &quot;(sorted-set-by #(&lt; (second %1) (second %2))\n  [:a 1] [:b 1] [:c 0])&quot; &quot;(conj nil (list 1 2 3))&quot; &quot;(conj (list 1 2 3) nil)&quot; &quot;(weighted-pairs-&gt;aliases\n  {:a 1 :b 2 :c 1})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:a 1 :b 1})&quot; &quot;(not-empty [])&quot; &quot;(not-empty [1 2])&quot; &quot;(enumarated-dist-&gt;aliases\n  {:a 1.0 :b 1.0 :c 1.0})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:a 1 :b 1 :c 2})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:a 1 :b 1 :c 1})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:a 1 :b 1 :c 3})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:A 0.28\n   :B 0.20\n   :C 0.05\n   :D 0.00\n   :E 0.12\n   :F 0.35})&quot; &quot;(enumarated-dist-&gt;aliases\n  {:A 0.28\n   :B 0.20\n   :C 0.05\n   :E 0.12\n   :F 0.35})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:A 0.28\n   :B 0.20\n   :C 0.05\n   :E 0.12\n   :F 0.35})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:a 1 :b 2})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:a 1 :b 1})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:a 1 :b 1 :c 2})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:A 0.28 :B 0.20 :C 0.05 :E 0.12 :F 0.35})&quot; &quot;(run-test\n  )&quot; &quot;(enumerated-distribution-gen\n  {(\&quot;Cristiano\&quot;) 1, (\&quot;ce\&quot;) 1, (\&quot;Zinédine\&quot;) 1, (\&quot;il\&quot;) 1, (\&quot;quatre\&quot;) 1, (\&quot;la\&quot;) 1})&quot; &quot;(run-get *1)&quot; &quot;(enumerated-distribution-gen\n  '{(\&quot;Cristiano\&quot;) 1, (\&quot;ce\&quot;) 1, (\&quot;Zinédine\&quot;) 1, (\&quot;il\&quot;) 1, (\&quot;quatre\&quot;) 1, (\&quot;la\&quot;) 1})&quot; &quot;(run-gen\n  (enumerated-distribution-gen\n  '{(\&quot;Cristiano\&quot;) 1, (\&quot;ce\&quot;) 1, (\&quot;Zinédine\&quot;) 1, (\&quot;il\&quot;) 1, (\&quot;quatre\&quot;) 1, (\&quot;la\&quot;) 1}))&quot; &quot;(enumerated-dist-&gt;aliases\n  '{(\&quot;Cristiano\&quot;) 1, (\&quot;ce\&quot;) 1, (\&quot;Zinédine\&quot;) 1, (\&quot;il\&quot;) 1, (\&quot;quatre\&quot;) 1, (\&quot;la\&quot;) 1})&quot; &quot;(enumerated-dist-&gt;aliases\n  {:a 1\n   :b 1\n   :c 1\n   :d 1\n   :e 1\n   :f 1})&quot; &quot;(count *1)&quot; &quot;(run-test)&quot; &quot;(test/run-tests)&quot;], :remote []}}</component>
</project>