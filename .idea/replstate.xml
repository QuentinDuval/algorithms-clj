<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1485098254631">{:repl-history {:ide [], :local [&quot;(run-all-tests)&quot; &quot;(defmacro simple-step-fct\n  \&quot;Build a simple step function for a transducer\&quot;\n  [bindings &amp; xf]\n  `(fn [xf]\n       (let ~bindings\n         (fn step-fn\n             ([] (xf))\n             ([result] (xf result))\n             ~xf))))&quot; &quot;(defn- huffman-xf\n  \&quot;Transducer step function to decode a huffman stream of values\&quot;\n  [huffman-tree]\n   (simple-step-fct\n     [branch (volatile! huffman-tree)]\n     ([result input]\n       (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            )))\n\n  #_(fn [xf]\n    (let [branch (volatile! huffman-tree)]\n      (fn step-fn\n        ([] (xf))\n        ([result] (xf result))\n        ([result input]\n          (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            ))\n        ))))&quot; &quot;(defmacro simple-step-fct\n  \&quot;Build a simple step function for a transducer\&quot;\n  [bindings &amp; xf]\n  `(fn [xf]\n       (let ~bindings\n         (fn step-fn\n             ([] (xf))\n             ([result] (xf result))\n             ~@xf))))&quot; &quot;(defn- huffman-xf\n  \&quot;Transducer step function to decode a huffman stream of values\&quot;\n  [huffman-tree]\n   (simple-step-fct\n     [branch (volatile! huffman-tree)]\n     ([result input]\n       (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            ))))&quot; &quot;(macroexpand-1 huffman-xf)&quot; &quot;(defmacro simple-step-fct\n          \&quot;Build a simple step function for a transducer\&quot;\n          [bindings &amp; step-fn]\n          `(fn [xf#]\n               (let ~bindings\n                    (fn\n                        ([] (xf#))\n                        ([result] (xf# result))\n                        ~@step-fn))))&quot; &quot;(defn- huffman-xf\n       \&quot;Transducer step function to decode a huffman stream of values\&quot;\n       [huffman-tree]\n       (simple-step-fct\n         [branch (volatile! huffman-tree)]\n         ([result input]\n           (let [next-branch (child-at @branch input)]\n                (if (is-leaf? next-branch)\n                  (do\n                    (vreset! branch huffman-tree)\n                    (xf result (leaf-val next-branch)))\n                  (do\n                    (vreset! branch next-branch)\n                    result))\n                ))))&quot; &quot;(simple-test 1 2)&quot; &quot;(defprotocol Parser\n  \&quot;Defining a protocol for what is a Parser in Clojure\&quot;\n  (on-success [this result input] \&quot;Transmit the parsing result to the next parser in the chain\&quot;)\n  (on-failure [this ] \&quot;Transmit the error to the next parser on the chain\&quot;))&quot; &quot;(defn word-parser\n  \&quot;Parses a word, until the next non-word character\&quot;\n  [next-parser]\n  (reify Parser\n    (on-success [result input]\n      (let [idx (str/index-of idx \&quot; \&quot;)\n            res (subs input 0 idx)\n            next (subs input (inc idx))]\n        (on-success\n          next-parser (conj res result) next)\n        ))\n    (on-failure [] (on-failure next-parser))\n    ))&quot; &quot;(defn test\n  []\n  (let [p (word-parser identity)]\n    (println (p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn parrsing-test\n  []\n  (let [p (word-parser identity)]\n    (println (p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn parsing-test\n  []\n  (let [p (word-parser identity)]\n    (println (on-success p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn terminal\n  []\n  (reify Parser\n    (on-success [_ result _] result)\n    (on-failure [_] \&quot;Failed miserably\&quot;)\n    ))&quot; &quot;(parsing-test)&quot; &quot;(mparsing-test)&quot; &quot;(run-tests)&quot;], :remote []}}</component>
</project>