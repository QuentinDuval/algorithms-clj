<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1495291489887">{:repl-history {:ide [], :local [&quot;(walk/macroexpand-all\n  '(add-mm x y))&quot; &quot;(defconstexpr add-mm\n  [a b]\n  `(add ~a ~b))&quot; &quot;(defmacro constexpr-2\n  [[fct &amp; args]]\n  (let [unquoted-args (map (fn [a] (unquote a)) args)]\n    `(~fct ~@unquoted-args)))&quot; &quot;(clojure.repl/doc unquote)&quot; &quot;(walk/macroexpand-all\n  '(constexpr-2 (add x y)))&quot; &quot;(unquote a)&quot; &quot;(test-add)&quot; &quot;(walk/macroexpand-all\n  '(defconstexpr add-mm\n     [a b]\n     (add ~a ~b)))&quot; &quot;(walk/macroexpand-all\n  '(defconstexpr add-mm\n     [a b]\n     `(add ~a ~b)))&quot; &quot;(walk/macroexpand-all\n  '(defconstexpr add-mm\n     [a b]\n     (add a b)))&quot; &quot;(walk/macroexpand-all '(average-m [1 2 3 1 2]))&quot; &quot;(average-m [1 2 3 1 2])&quot; &quot;(average-m [1 2 4 5])&quot; &quot;(walk/macroexpand-all '(average-m [1 2 3 5]))&quot; &quot;(walk/macroexpand-all '(average-m [1 2 4 5]))&quot; &quot;(let [a 1\n      b 2]\n  (average-m [a b]))&quot; &quot;pi&quot; &quot;(number? 3.14)&quot; &quot;(number? 3)&quot; &quot;(reduce + [1  2 3])&quot; &quot;(optimize-expr [+ [* 2 3.14 :a] [* 2 :b :c]])&quot; &quot;(test-def-expr)&quot; &quot;(symbol? &amp;)&quot; &quot;(symbol? '&amp;)&quot; &quot;(walk/macroexpand-all\n  '(defn-log add\n     [a b]\n     (+ a b)))&quot; &quot;(add-with-log)&quot; &quot;(add-with-log 1 2)&quot; &quot;(walk/macroexpand-all '(freq-map-m [1 2 1 4 1 3]))\n&quot; &quot;(walk/macroexpand-all '(freq-map-m [1 2 1 4 1 3]))&quot; &quot;(time (walk/macroexpand-all '(freq-map-m [1 2 1 4 1 3])))&quot; &quot;(time (walk/macroexpand-all\n        '(freq-map-m (range 10000))\n        ))&quot; &quot;(do\n  (time (walk/macroexpand-all\n        '(freq-map-m (range 10000))\n        ))\n  nil)&quot; &quot;(let [coll (into [] (range 10000))]\n  (time (walk/macroexpand-all\n        '(freq-map-m coll)\n        ))\n  nil)&quot; &quot;(def coll (vec (range 10000)))&quot; &quot;(persistent! (transient {}))&quot; &quot;(defn freq-map\n  [coll]\n  (persitent!\n    (reduce\n      (fn [freqs val] (update freqs val (fnil + 0) 1))\n      (transient {})\n      coll)))&quot; &quot;(do (time (frequencies coll\n            )) nil)&quot; &quot;(do (time (frequencies coll)) nil)&quot; &quot;(clojure.repl/doc frequencies)&quot; &quot;(clojure.repl/source frequencies)&quot; &quot;(def coll (into []\n            (concat (range 5000) (range 5000))\n            ))&quot; &quot;(do\n  (time (walk/macroexpand-all\n        '(freq-map-m coll)\n        ))\n  nil)&quot; &quot;(java.util.HashMap.)&quot; &quot;(doseq [i (range 10)]\n  (println i))&quot; &quot;(freq-map-opt [1 2 3 4])&quot; &quot;(count coll)&quot; &quot;(do\n  (time (freq-map-opt coll))\n  nil)&quot; &quot;(do\n  (time (freq-map coll))\n  nil)&quot; &quot;(do\n  (time (walk/macroexpand-all '(freq-map-m coll)))\n  nil)&quot; &quot;(freq-map-opt [1 2 3 4 5])&quot; &quot;(freq-map-opt [1 2 3 4 5 1 1 1])&quot; &quot;(walk/macroexpand-all\n  '(defn-log add-with-log [a b] (+ a b)))&quot; &quot;(test-add-with-log)&quot; &quot;(test-add-with-log-3\n  )&quot; &quot;(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  coll)&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  coll))&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n     + 0\n     []\n     coll))&quot; &quot;(make)&quot; &quot;(int-ar)&quot; &quot;(test-reducer () s)&quot; &quot;(test-inline-reduce)&quot; &quot;(tset-reducers)&quot; &quot;(test-reducers)&quot; &quot;(repeat-n 3 \&quot;toto\&quot;)&quot; &quot;(test-add-with-log-3)&quot; &quot;(def a 1)&quot; &quot;(def b 1)&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; (quote [a b]) [a b])&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; `[a b] [a b])&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; '[a b] [a b])&quot; &quot;(run)&quot; &quot;(browser-repl)&quot; &quot;(clojure.repl/doc s/coll-of)&quot; &quot;(clojure.repl/source\n  s/coll-of)&quot; &quot;(cljs.repl/doc any?)&quot; &quot;(cljs.repl/doc s/coll-of\n  )&quot; &quot;(cljs.repl/source any?)&quot; &quot;(cljs.repl/source s/coll-of)&quot; &quot;(s/valid? ::binary-tree-impl sample-tree)&quot; &quot;(s/def ::int-binary-tree\n  (binary-tree-of int?))&quot; &quot;(dfs-binary-tree sample-tree)&quot; &quot;(macroexpand-1 '(binary-tree-of int?))&quot; &quot;(s/valid? ::big-even 1001)&quot; &quot;(s/valid? ::big-even 1002)&quot; &quot;(s/explain ::int-binary-tree sample-tree)&quot; &quot;(s/explain ::int-binary-tree-macro sample-tree)&quot; &quot;(s/explain\n  ::int-binary-tree-macro\n  sample-tree-2)&quot; &quot;(s/explain\n  ::int-binary-tree\n  sample-tree)&quot; &quot;(s/explain\n  ::int-binary-tree-macro\n  sample-tree)&quot; &quot;(require '[clojure.walk])&quot; &quot;(require '[clojure.walk :as w])&quot; &quot;(w/macroexpand-all '(+ 1 2))&quot; &quot;(macroexpand '(+ 2 1))&quot; &quot;(s/valid? ::int-binary-tree sample-tree)&quot; &quot;(s/valid? ::int-binary-tree-macro sample-tree)&quot; &quot;(macroexpand '(binary-tree-of int?))&quot; &quot;:cljs/quit&quot; &quot;(clojure.walk/macroexpand-all\n  '(binary-tree-of int?))&quot; &quot;(user/run)&quot; &quot;(user/browser-repl)&quot; &quot;(s/def ::int-binary-tree-macro\n  (binary-tree-of int?))&quot;], :remote []}}</component>
</project>