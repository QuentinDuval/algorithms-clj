<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1493475127013">{:repl-history {:ide [], :local [&quot;(test-expr)&quot; &quot;(test-walk)&quot; &quot;(defn maxlwplp [a b e h r u v w x] (* (+ 7) (* h) -13 29 b (* x) -23 12 -7 (+ e) 30 v (+ -16) -18 w (+ 28) a r h (* 16) (+ -27) u -21 u (* u) -22))&quot; &quot;(maxlwplp 1 2 3 4 5 6 7 8 0)&quot; &quot;(add* 1 2)&quot; &quot;(add 1 2)&quot; &quot;(macroexpand (add* 1 2))&quot; &quot;(macroexpand (add 1 2))&quot; &quot;(add* x y)&quot; &quot;(defn test-add\n  []\n  (let [x 1\n        y 2]\n    (println (add 1 2))\n    (println (add-m 1 2))\n    ))&quot; &quot;(defn test-add\n  []\n  (let [x 1\n        y 2]\n    (println (add x y))\n    (println (add-m x y))\n    ))&quot; &quot;(defn test-add\n  []\n  (let [x 1\n        y 2]\n    (println (add x y))\n    (println (add-m 1 2))\n    ;; Does not compile: cannot add symbols\n    ; (println (add-m x y))\n    (println (add-m-2 x y))\n    ))&quot; &quot;(average [1 2 3])&quot; &quot;(defmacro m1 1)&quot; &quot;(defmacro m1 [] 1)&quot; &quot;(macroexpand m1)&quot; &quot;(macroexpand (m1))&quot; &quot;(add-m (m1) (m1))&quot; &quot;(printl n(add-m (m1) (m1)))&quot; &quot;(println (add-m (m1) (m1)))&quot; &quot;(defn test-add\n  []\n  (let [x 1\n        y 2]\n    (println (add x y))\n    (println (add-m 1 2))\n\n    ;; Does not compile: cannot add symbols (explain this)\n    ;; (println (add-m x y))\n    ;; (println (add-m-2 x y))\n\n    ;; This however should work\n    (defmacro x1 [] 1)\n    (defmacro x2 [] 2)\n    (println (add-m (x1) (x2)))\n    ))&quot; &quot;(average-m [1 2 3])&quot; &quot;(average-m [1 2 3 4 5])&quot; &quot;(average-m [1 2 3 4])&quot; &quot;(average-m [1 2 3 m1])&quot; &quot;(average-m [1 2 3 (m1)])&quot; &quot;(defn test-average\n  []\n  (let [coll [1 2 3]]\n    (println (average coll))\n    ;; (println (average-m coll)) ;; Would not compile\n    (println (average-m [1 2 3]))\n\n    (defmacro coll-m [] [1 2 3])\n    (println (average-m (coll-m)))\n    ))&quot; &quot;(repeat 3 1)&quot; &quot;(def print-3\n  (times-3 (println \&quot;1\&quot;)))&quot; &quot;(defn print-3 [] (times-3 (println \&quot;1\&quot;)))&quot; &quot;(print-3)&quot; &quot;(defn print-3-2 [] (times-3-2 (println \&quot;1\&quot;)))&quot; &quot;(print-3-2)&quot; &quot;(times-n)&quot; &quot;(time-n)&quot; &quot;(partition 4 [1 2 3 4 5])&quot; &quot;(test-unroll-loop)&quot; &quot;(macroexpand(unrolled-loop 10 (println \&quot;Yoh\&quot;)))&quot; &quot;(macroexpand-1\n  (unrolled-loop 10 (println \&quot;Yoh\&quot;)))&quot; &quot;(defn test-freq-map\n  []\n  (let [inputs [1 2 1 4 1 3]]\n    (println (freq-map inputs))\n    (println (freq-map-m [1 2 1 4 1 3]))\n\n    (defmacro inputs-m [] [1 2 1 4 1 3])\n    (println (freq-map-m (inputs-m)))\n    ))&quot; &quot;(defmacro c1 [] [1 2 3])&quot; &quot;(macroexpand\n  (freq-map-m (c1)))&quot; &quot;(quote (macroexpand-1\n  (freq-map-m (c1))))&quot; &quot;(macroexpand-1\n  (freq-map-m (c1)))&quot; &quot;(require 'clojure.walk\n  )&quot; &quot;(clojure.walk/macroexpand-all\n  (freq-map-m (c1))\n  )&quot; &quot;(clojure.walk/macroexpand-all\n  (freq-map-m (c1)))&quot; &quot;(clojure.walk/macroexpand-all\n  (freq-map-m [1 2 3]))&quot; &quot;(macroexpand-1\n  (freq-map-m [1 2 3]))&quot; &quot;(report\n  (clojure.walk/macroexpand-all (freq-map-m (c1)))\n  )&quot; &quot;(report\n  (freq-map-m (c1))\n  )&quot; &quot;(walk/macroexpand-all\n  (-&gt; 1 (* 2)))&quot; &quot;(walk/macroexpand-all\n  '(-&gt; 1 (* 2)))&quot; &quot;(walk/macroexpand-all\n  '(freq-map-m (c1))\n  )&quot; &quot;(expension-report (-&gt; 1 (* 2)))&quot; &quot;(expension-report (-&gt; 1 (* 2) (* 3)))&quot; &quot;(defmacro n1 [] 1)\n(expension-report )&quot; &quot;(defmacro n1 [] 1)\n&quot; &quot;(expension-report\n  (+ (n1)))&quot; &quot;(expension-report\n  (add (n1) (n1)))&quot; &quot;(expension-report\n  (add-m (n1) (n1)))&quot; &quot;(expension-report\n  (add-m-2 (n1) (n1)))&quot; &quot;(expension-report\n  (add-m-3 (n1) (n1)))&quot; &quot;(defmacro add-m-4\n  [a b]\n  (let [x# ~a\n        y# ~b]\n    (+ x# y#)\n    ))&quot; &quot;(defmacro add-m-4\n  [&amp; xs]\n  `(+ ~@xs))&quot; &quot;(defmacro add-m-4\n  [&amp; xs]\n  (eval `(+ ~@xs)))&quot; &quot;(expension-report\n  (add-m-4 (n1) (n1)))&quot; &quot;(add-m (c1) (c1))&quot; &quot;(defmacro add-m-4\n  [a b]\n  (constexpr add a b))&quot; &quot;(defmacro constexpr\n  [fct &amp; args]\n  (eval `(fct ~@args)))&quot; &quot;(defmacro constexpr\n  [fct &amp; args]\n  (eval `(~fct ~@args)))&quot; &quot;(constexpr + 1 2)&quot; &quot;(defmacro add-m-4\n  [a b]\n  ;;`(constexpr add ~a ~b)\n  (constexpr add a b)\n  )&quot; &quot;(test-add)&quot; &quot;(defmacro average-m\n  \&quot;Average of numbers known at compile time\&quot;\n  [coll]\n  ;; TODO - How to get rid of eval???\n  (constexpr average ~coll))&quot; &quot;(clojure.walk/macroexpand-all\n  (average-m (c1)))&quot; &quot;(c1)&quot; &quot;(defmacro c1 [] [1 2 3 4])&quot; &quot;(clojure.walk/macroexpand-all\n  '(average-m (c1)))&quot; &quot;(report\n  (average-m (c1)))&quot; &quot;(test-freq-map)&quot; &quot;(test-average)&quot; &quot;(defn-log add-log\n  [a b]\n  (+ a b))&quot; &quot;(add-log 1 2)&quot; &quot;(test-add-log)&quot; &quot;(reset! logger nil)&quot; &quot;(test-add-log-2)&quot; &quot;(defn logger-on [] false)&quot; &quot;(test-add-log-3)&quot; &quot;(first [])&quot; &quot;(odd? 2)&quot; &quot;(first nil)&quot; &quot;(walk/macroexpand-all\n  '(inline-reducer\n    +\n    [[:map #(* 2 %)]]\n    5\n    1))&quot; &quot;(walk/macroexpand-all\n  (inline-reducer\n    +\n    [[:map #(* 2 %)]]\n    5\n    1))&quot; &quot;(macroexpand-1\n  (inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  coll))&quot; &quot;(macroexpand-1\n  (inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  [1 2 3]))&quot; &quot;(macroexpand-1\n  '(inline-reduce\n    + 0\n    [[:filter odd?] [:map #(* 2 %)]]\n    [1 2 3]))&quot; &quot;(macroexpand\n  (inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  [1 2 3]))&quot; &quot;(macroexpand\n  '(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  [1 2 3]))&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  [1 2 3]))&quot; &quot;(test-inline-reduce)&quot;], :remote []}}</component>
</project>