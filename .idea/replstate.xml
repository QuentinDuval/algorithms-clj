<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1495884176235">{:repl-history {:ide [], :local [&quot;(walk/macroexpand-all\n  '(defn-log add-with-log [a b] (+ a b)))&quot; &quot;(test-add-with-log)&quot; &quot;(test-add-with-log-3\n  )&quot; &quot;(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  coll)&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n  + 0\n  [[:filter odd?] [:map #(* 2 %)]]\n  coll))&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n     + 0\n     []\n     coll))&quot; &quot;(make)&quot; &quot;(int-ar)&quot; &quot;(test-reducer () s)&quot; &quot;(test-inline-reduce)&quot; &quot;(tset-reducers)&quot; &quot;(test-reducers)&quot; &quot;(test-add-with-log-3)&quot; &quot;(def b 1)&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; (quote [a b]) [a b])&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; `[a b] [a b])&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; '[a b] [a b])&quot; &quot;(clojure.repl/doc s/coll-of)&quot; &quot;(clojure.repl/source\n  s/coll-of)&quot; &quot;(cljs.repl/doc any?)&quot; &quot;(cljs.repl/doc s/coll-of\n  )&quot; &quot;(cljs.repl/source any?)&quot; &quot;(cljs.repl/source s/coll-of)&quot; &quot;(s/valid? ::binary-tree-impl sample-tree)&quot; &quot;(s/def ::int-binary-tree\n  (binary-tree-of int?))&quot; &quot;(dfs-binary-tree sample-tree)&quot; &quot;(macroexpand-1 '(binary-tree-of int?))&quot; &quot;(s/valid? ::big-even 1001)&quot; &quot;(s/valid? ::big-even 1002)&quot; &quot;(s/explain ::int-binary-tree sample-tree)&quot; &quot;(s/explain ::int-binary-tree-macro sample-tree)&quot; &quot;(s/explain\n  ::int-binary-tree-macro\n  sample-tree-2)&quot; &quot;(s/explain\n  ::int-binary-tree\n  sample-tree)&quot; &quot;(s/explain\n  ::int-binary-tree-macro\n  sample-tree)&quot; &quot;(require '[clojure.walk])&quot; &quot;(require '[clojure.walk :as w])&quot; &quot;(w/macroexpand-all '(+ 1 2))&quot; &quot;(macroexpand '(+ 2 1))&quot; &quot;(s/valid? ::int-binary-tree sample-tree)&quot; &quot;(s/valid? ::int-binary-tree-macro sample-tree)&quot; &quot;(macroexpand '(binary-tree-of int?))&quot; &quot;:cljs/quit&quot; &quot;(clojure.walk/macroexpand-all\n  '(binary-tree-of int?))&quot; &quot;(user/run)&quot; &quot;(user/browser-repl)&quot; &quot;(s/def ::int-binary-tree-macro\n  (binary-tree-of int?))&quot; &quot;(run)&quot; &quot;(browser-repl)&quot; &quot;(println (s/valid? (binary-tree-of int?) sample-tree))&quot; &quot;(s/valid? (binary-tree-of (binary-tree-of int?)) sample-tree)\n&quot; &quot;(s/valid? even? 2)&quot; &quot;(s/valid? (binary-tree-of \n            (binary-tree-of any))\n  sample-tree)&quot; &quot;(s/valid?\n  (s/coll-of\n    (s/coll-of any?))\n  [[]])&quot; &quot;(s/valid? (binary-tree-of \n            (binary-tree-of any?))\n  sample-tree)&quot; &quot;(s/def ::bbtree (binary-tree-of (binary-tree-of any?)))&quot; &quot;(+ 1 2)&quot; &quot;(s/valid?\n  (binary-tree-of (binary-tree-of any?))\n  [sample-tree {}])&quot; &quot;(s/valid?\n  (binary-tree-of\n    (binary-tree-of any?))\n  sample-tree)&quot; &quot;(s/explain\n  (binary-tree-of\n    (binary-tree-of any?))\n  sample-tree)&quot; &quot;(def a 1)&quot; &quot;(def b 2)&quot; &quot;(log-symbol-values\n  \&quot;Prefix: \&quot; ;; Prefix of the log\n  '[a b]     ;; Quoted variables list\n  [a b])    ;; Values of variables&quot; &quot;(log-symbol-values\n  (function-log-prefix \&quot;add\&quot;)\n  '[a b]     ;; Quoted variables list\n  [a b])    ;; Values of variables&quot; &quot;(log-symbol-values\n  (function-log-prefix \&quot;add\&quot;)\n  '[a b]     ;; Quoted variables list\n   [a b])    ;; Values of variables&quot; &quot;(repeat-n-with-logs 3 \&quot;hello\&quot;)&quot; &quot;(repeat-n 3 \&quot;toto\&quot;)&quot; &quot;(walk/macroexpand-all\n  '(defn-log repeat-n\n     [n s]\n     (apply str (repeat n s))))&quot; &quot;(macroexpand\n  '(defn-log repeat-n\n     [n s]\n     (apply str (repeat n s))))&quot; &quot;(macroexpand-1\n  '(defn-log repeat-n\n     [n s]\n     (apply str (repeat n s))))&quot; &quot;(compile-log-message\n  \&quot;my-function\&quot;\n  '[a b])&quot; &quot;(defn head-and-tail\n  [x &amp; xs]\n  {:head x\n   :tail xs})&quot; &quot;(defn head-and-tail\n  [[x &amp; xs]]\n  {:head x\n   :tail xs})&quot; &quot;(defn-log head-and-tail\n  [[x &amp; xs]]\n  {:head x\n   :tail xs})&quot; &quot;(head-and-tail [1 2 3])&quot; &quot;(add-with-log-3 1 2)&quot; &quot;(fibo-iterate 1000)&quot; &quot;(time)&quot; &quot;(time\n  (fibo-iterate 1000))&quot; &quot;((time (fibo-iterate 1000)) nil)&quot; &quot;(do\n  (time (fibo-iterate 1000)) nil)&quot; &quot;(do\n  (time (fibo-iterate 1000))\n  nil)&quot; &quot;(do\n  (time (fibo-lazy-seq 1000))\n  nil)&quot; &quot;(fibo-imperative 0)&quot; &quot;(fibo-imperative 1)&quot; &quot;(fibo-imperative 3)&quot; &quot;(fibo-imperative 4)&quot; &quot;(fibo-imperative 5)&quot; &quot;(fibo-imperative 6)&quot; &quot;(fibo-imperative 2)&quot; &quot;(do\n  (time (fibo-imperative 1000))\n  nil)&quot; &quot;(fibo-recur 5)&quot; &quot;(do\n  (time (fibo-recur 1000))\n  nil\n  )&quot; &quot;(do\n  (time (fibo-recur 1000))\n  nil)&quot; &quot;(use 'criterium.core)\n&quot; &quot;(bench (fibo-iterate 1000))&quot; &quot;(with-progress-reporting\n  (quick-bench (fibo-iterate 1000) :verbose))\n&quot; &quot;(quick-bench (fibo-iterate 1000) :verbose)\n&quot; &quot;(run-benches)&quot; &quot;(perf/quick-bench (fibo-lazy-cat n))&quot; &quot;(fibo-lazy-cat 5)&quot; &quot;(perf/quick-bench (fibo-lazy-cat 1000))&quot;], :remote []}}</component>
</project>