<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1495994459476">{:repl-history {:ide [], :local [&quot;(head-and-tail [1 2 3])&quot; &quot;(add-with-log-3 1 2)&quot; &quot;(fibo-iterate 1000)&quot; &quot;(time)&quot; &quot;(time\n  (fibo-iterate 1000))&quot; &quot;((time (fibo-iterate 1000)) nil)&quot; &quot;(do\n  (time (fibo-iterate 1000)) nil)&quot; &quot;(do\n  (time (fibo-iterate 1000))\n  nil)&quot; &quot;(do\n  (time (fibo-lazy-seq 1000))\n  nil)&quot; &quot;(fibo-imperative 0)&quot; &quot;(fibo-imperative 1)&quot; &quot;(fibo-imperative 3)&quot; &quot;(fibo-imperative 4)&quot; &quot;(fibo-imperative 5)&quot; &quot;(fibo-imperative 6)&quot; &quot;(fibo-imperative 2)&quot; &quot;(do\n  (time (fibo-imperative 1000))\n  nil)&quot; &quot;(fibo-recur 5)&quot; &quot;(do\n  (time (fibo-recur 1000))\n  nil\n  )&quot; &quot;(do\n  (time (fibo-recur 1000))\n  nil)&quot; &quot;(use 'criterium.core)\n&quot; &quot;(bench (fibo-iterate 1000))&quot; &quot;(with-progress-reporting\n  (quick-bench (fibo-iterate 1000) :verbose))\n&quot; &quot;(quick-bench (fibo-iterate 1000) :verbose)\n&quot; &quot;(perf/quick-bench (fibo-lazy-cat n))&quot; &quot;(fibo-lazy-cat 5)&quot; &quot;(perf/quick-bench (fibo-lazy-cat 1000))&quot; &quot;(fibo-volatile 5)&quot; &quot;(fibo-volatile 1000)&quot; &quot;(perf/quick-bench\n  (fibo-volatile 1000))&quot; &quot;(bind [*unchecked-math* true]\n  (perf/quick-bench\n    (fibo-volatile 1000)))&quot; &quot;(binding [*unchecked-math* true]\n  (perf/quick-bench\n    (fibo-volatile 1000)))&quot; &quot;(perf/quick-bench (fibo-recur 1000))&quot; &quot;(FiboType. 0N 1N)&quot; &quot;(advance *1 5)&quot; &quot;(fibo-with-type 1000)&quot; &quot;(perf/quick-bench\n  (fibo-with-type 1000))&quot; &quot;(macroexpand-1 (run-bench fibo-iterate 10))&quot; &quot;(macroexpand-1 '(run-bench fibo-iterate 10))&quot; &quot;(fibo-trampoline 5)&quot; &quot;(perf/quick-bench (fibo-trampoline 1000))&quot; &quot;(type 0N)&quot; &quot;(import 'algorithms-clj.PerfFiboJava)&quot; &quot;(import 'java.algorithms.PerfFiboJava)&quot; &quot;(import javaalg.algorithms.PerfFiboJava)&quot; &quot;(import 'javaalg.algorithms.PerfFiboJava)&quot; &quot;(PerfFiboJava/fibs 1)&quot; &quot;(PerfFiboJava/fibs. 1)&quot; &quot;(.fibs PerfFiboJava. 1)&quot; &quot;(.fibs (PerfFiboJava.) 1)&quot; &quot;(fibo-with-java 1)&quot; &quot;(fibo-with-java 5)&quot; &quot;(run-bench (fibo-with-java 1000))&quot; &quot;(fibo-with-java 1000)&quot; &quot;(/ 44 (* 1.52 1.52))&quot; &quot;(/ 77.5 (* 1.9 1.9))&quot; &quot;(run-bench\n  (fibo-recur 1000))&quot; &quot;(run-bench\n  (fibo-recur-java-bigint 1000))&quot; &quot;(fibo-with-type 5)&quot; &quot;(fibo-iterate-2 5)&quot; &quot;(run-bench (fibo-iterate-2 1000))&quot; &quot;(defn yolo\n  []\n  (let [a (FiboType. 0N 1N)]\n    (.curr a)))&quot; &quot;(yolo)&quot; &quot;(deftype ImmutableFibo [a b])&quot; &quot;(.a (ImmutableFibo 0N 1N))&quot; &quot;(.a (ImmutableFibo. 0N 1N))&quot; &quot;(.curr (FiboType. 0N 1N))&quot; &quot;(type (BigInteger/valueOf 1))&quot; &quot;(run-bench (fibo-recur-java-bigint 1000))&quot; &quot;(perf/quick-bench (reduce + (range 1000)))&quot; &quot;(reduce + (range 1000))&quot; &quot;(perf/quick-bench (fibo-recur-java-bigint 1000))&quot; &quot;(run-benches)&quot; &quot;(run-bench (fibo-lazy-seq 1000))&quot; &quot;(test-inline-reduce)&quot; &quot;(run-bench\n  \&quot;Naive reduction\&quot;\n  (fn [coll] (reduce + 0 (mapcat repeat-2 (map #(* 2 %) (filter odd? coll)))))\n  (vec (range 5000)))&quot; &quot;(run-bench\n  \&quot;Naive reduction\&quot;\n  (fn [coll] (reduce + 0 (mapcat (fn [x] [x x]) (map #(* 2 %) (filter odd? coll)))))\n  (vec (range 5000)))&quot; &quot;(bench-reducers)&quot; &quot;(walk/macroexpand-all\n  '(inline-reduce\n     + 0\n     []\n     coll))&quot; &quot;(inline-reduce\n  + 0\n  []\n  (into-array coll))&quot; &quot;(inline-reduce\n  + 0\n  []\n  (into-array (range 10)))&quot; &quot;(inlined-reduce (vec (range 1000)))&quot; &quot;(str/split text #\&quot; \&quot;)&quot; &quot;(str/split \&quot;this is a sentence\&quot; #\&quot; \&quot;)&quot; &quot;(get {:a 1} :a (Thread/sleep 10))&quot; &quot;(get {:a 1} :a (Thread/sleep 1000))&quot; &quot;(or (get {:a 1} :a) (Thread/sleep 1000))&quot; &quot;(rand-nth [1 2 3])&quot; &quot;(transitions\n  (split-words \&quot;this is a simple test sentence\&quot;)\n  3)&quot; &quot;(transitions\n  (split-words \&quot;this is a simple test sentence\n                this is a stupid sentence\&quot;)\n  3)&quot; &quot;(transitions\n  (split-words \&quot;this is a simple test sentence this is a stupid sentence\&quot;)\n  3)&quot; &quot;(read)&quot; &quot;(read-transitions\n  (split-words \&quot;this is a simple test sentence this is a stupid sentence\&quot;)\n  3)&quot; &quot;(str/j)&quot; &quot;(split-with pos? [1 -1 2])&quot; &quot;(split-with pos? [1 -1 2 -2 1])&quot; &quot;(Character/isUpperCase \\c)&quot; &quot;(Character/isUpperCase \\C)&quot; &quot;(partition 2\n  (partition-by #(Character/isUpperCase %) \&quot;MyClassName\&quot;))&quot; &quot;(split-class-name \&quot;MyFuckingClass\&quot;)&quot; &quot;(run-test)&quot;], :remote []}}</component>
</project>