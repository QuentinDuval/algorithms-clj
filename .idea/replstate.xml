<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1492967268535">{:repl-history {:ide [], :local [&quot;(run-all-tests)&quot; &quot;(defmacro simple-step-fct\n  \&quot;Build a simple step function for a transducer\&quot;\n  [bindings &amp; xf]\n  `(fn [xf]\n       (let ~bindings\n         (fn step-fn\n             ([] (xf))\n             ([result] (xf result))\n             ~xf))))&quot; &quot;(defn- huffman-xf\n  \&quot;Transducer step function to decode a huffman stream of values\&quot;\n  [huffman-tree]\n   (simple-step-fct\n     [branch (volatile! huffman-tree)]\n     ([result input]\n       (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            )))\n\n  #_(fn [xf]\n    (let [branch (volatile! huffman-tree)]\n      (fn step-fn\n        ([] (xf))\n        ([result] (xf result))\n        ([result input]\n          (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            ))\n        ))))&quot; &quot;(defmacro simple-step-fct\n  \&quot;Build a simple step function for a transducer\&quot;\n  [bindings &amp; xf]\n  `(fn [xf]\n       (let ~bindings\n         (fn step-fn\n             ([] (xf))\n             ([result] (xf result))\n             ~@xf))))&quot; &quot;(defn- huffman-xf\n  \&quot;Transducer step function to decode a huffman stream of values\&quot;\n  [huffman-tree]\n   (simple-step-fct\n     [branch (volatile! huffman-tree)]\n     ([result input]\n       (let [next-branch (child-at @branch input)]\n            (if (is-leaf? next-branch)\n              (do\n                (vreset! branch huffman-tree)\n                (xf result (leaf-val next-branch)))\n              (do\n                (vreset! branch next-branch)\n                result))\n            ))))&quot; &quot;(macroexpand-1 huffman-xf)&quot; &quot;(defmacro simple-step-fct\n          \&quot;Build a simple step function for a transducer\&quot;\n          [bindings &amp; step-fn]\n          `(fn [xf#]\n               (let ~bindings\n                    (fn\n                        ([] (xf#))\n                        ([result] (xf# result))\n                        ~@step-fn))))&quot; &quot;(defn- huffman-xf\n       \&quot;Transducer step function to decode a huffman stream of values\&quot;\n       [huffman-tree]\n       (simple-step-fct\n         [branch (volatile! huffman-tree)]\n         ([result input]\n           (let [next-branch (child-at @branch input)]\n                (if (is-leaf? next-branch)\n                  (do\n                    (vreset! branch huffman-tree)\n                    (xf result (leaf-val next-branch)))\n                  (do\n                    (vreset! branch next-branch)\n                    result))\n                ))))&quot; &quot;(simple-test 1 2)&quot; &quot;(defprotocol Parser\n  \&quot;Defining a protocol for what is a Parser in Clojure\&quot;\n  (on-success [this result input] \&quot;Transmit the parsing result to the next parser in the chain\&quot;)\n  (on-failure [this ] \&quot;Transmit the error to the next parser on the chain\&quot;))&quot; &quot;(defn word-parser\n  \&quot;Parses a word, until the next non-word character\&quot;\n  [next-parser]\n  (reify Parser\n    (on-success [result input]\n      (let [idx (str/index-of idx \&quot; \&quot;)\n            res (subs input 0 idx)\n            next (subs input (inc idx))]\n        (on-success\n          next-parser (conj res result) next)\n        ))\n    (on-failure [] (on-failure next-parser))\n    ))&quot; &quot;(defn test\n  []\n  (let [p (word-parser identity)]\n    (println (p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn parrsing-test\n  []\n  (let [p (word-parser identity)]\n    (println (p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn parsing-test\n  []\n  (let [p (word-parser identity)]\n    (println (on-success p [] \&quot;my first sentence\&quot;))\n    ))&quot; &quot;(defn terminal\n  []\n  (reify Parser\n    (on-success [_ result _] result)\n    (on-failure [_] \&quot;Failed miserably\&quot;)\n    ))&quot; &quot;(parsing-test)&quot; &quot;(mparsing-test)&quot; &quot;(run-tests)&quot; &quot;(print-expr expr-1)&quot; &quot;expr-1&quot; &quot;(walk/postwalk\n  #(do (println %) %)\n  expr-1)&quot; &quot;(walk/postwalk\n  #(do (println %) %)\n  [:add 1 [:mul \&quot;x\&quot; 2]])&quot; &quot;(walk/postwalk\n  #(do (print (str % \&quot; \&quot;)) %)\n  [:add 1 [:mul \&quot;x\&quot; 2]])&quot; &quot;(group-by cst? [1 2 :add])&quot; &quot;(def expr\n  (add\n    (cst 1) (cst 2)\n    (mul (cst 0) (sym \&quot;x\&quot;) (sym \&quot;y\&quot;))\n    (mul (cst 1) (sym \&quot;y\&quot;) (cst 2))\n    (add (cst 0) (sym \&quot;x\&quot;))))&quot; &quot;(optimize expr)&quot; &quot;(print-exr (optimize expr))&quot; &quot;(print-expr (optimize expr))&quot; &quot;(print-expr expr)&quot; &quot;(print-expr\n  (partial-eval {\&quot;y\&quot; 0} expr))&quot; &quot;(print-expr (partial-eval {\&quot;x\&quot; 1 \&quot;y\&quot; 2} expr))&quot; &quot;(partial-eval {\&quot;x\&quot; 1 \&quot;y\&quot; 2} expr)&quot; &quot;(evaluate {\&quot;x\&quot; 1 \&quot;y\&quot; 2} expr)&quot; &quot;(rands [:add 1 2])&quot; &quot;(rands [:add [1] [2]])&quot; &quot;(concat (rands [:add [1] [2]]))&quot; &quot;(compile-expr expr-1)&quot; &quot;(eval-bytecode\n  {\&quot;x\&quot; 1 \&quot;y\&quot; 2}\n  (compile-expr expr-1))&quot; &quot;(test-expr)&quot; &quot;(test-walk)&quot; &quot;(defn maxlwplp [a b e h r u v w x] (* (+ 7) (* h) -13 29 b (* x) -23 12 -7 (+ e) 30 v (+ -16) -18 w (+ 28) a r h (* 16) (+ -27) u -21 u (* u) -22))&quot; &quot;(maxlwplp 1 2 3 4 5 6 7 8 0)&quot;], :remote []}}</component>
</project>